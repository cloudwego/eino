/*
 * Copyright 2025 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package prebuilt

import (
	"context"
	"errors"
	"fmt"
	"io"
	"runtime/debug"
	"strings"

	"github.com/bytedance/sonic"

	"github.com/cloudwego/eino/adk"
	"github.com/cloudwego/eino/components/model"
	"github.com/cloudwego/eino/components/prompt"
	"github.com/cloudwego/eino/internal/safe"
	"github.com/cloudwego/eino/schema"
)

// Plan represents an execution plan with a sequence of actionable steps.
// It provides methods to access the plan's description and retrieve the next step to execute.
type Plan interface {
	// Description returns the complete textual description of the plan.
	Description(ctx context.Context) string
	// FirstStep returns the next step to be executed in the plan.
	FirstStep(ctx context.Context) string
}

type PlanParser func(ctx context.Context, arguments string) (Plan, error)

// executionPlan the default implementation of Plan.
//
// JSON Schema:
//
//	{
//	  "type": "object",
//	  "properties": {
//	    "steps": {
//	      "type": "array",
//	      "items": {
//	        "type": "string"
//	      },
//	      "description": "Ordered list of actions to be taken. Each step should be clear, actionable, and arranged in a logical sequence."
//	    }
//	  },
//	  "required": ["steps"]
//	}
type executionPlan struct {
	// Steps contains the ordered list of actions to be taken.
	// Each step should be clear, actionable, and arranged in a logical sequence.
	Steps_ []string `json:"steps"`
}

func (p *executionPlan) Description(ctx context.Context) string {
	var formattedPlan strings.Builder
	for i, step := range p.Steps_ {
		formattedPlan.WriteString(fmt.Sprintf("%d. %s\n", i+1, step))
	}

	return formattedPlan.String()
}

func (p *executionPlan) FirstStep(ctx context.Context) string {
	if len(p.Steps_) == 0 {
		return ""
	}
	return p.Steps_[0]
}

// Response represents the final response to the user.
// This struct is used for JSON serialization/deserialization of the final response
// generated by the model.
type Response struct {
	// Response is the complete response to provide to the user.
	// This field is required.
	Response string `json:"response"`
}

var (
	// PlanToolInfo defines the schema for the Plan tool that can be used with ToolCallingChatModel.
	// This schema instructs the model to generate a structured plan with ordered steps.
	PlanToolInfo = schema.ToolInfo{
		Name: "Plan",
		Desc: "Plan with a list of steps to execute in order. Each step should be clear, actionable, and arranged in a logical sequence. The output will be used to guide the execution process.",
		ParamsOneOf: schema.NewParamsOneOfByParams(
			map[string]*schema.ParameterInfo{
				"steps": {
					Type:     schema.Array,
					ElemInfo: &schema.ParameterInfo{Type: schema.String},
					Desc:     "different steps to follow, should be in sorted order",
					Required: true,
				},
			},
		),
	}

	// RespondToolInfo defines the schema for the response tool that can be used with ToolCallingChatModel.
	// This schema instructs the model to generate a direct response to the user.
	RespondToolInfo = schema.ToolInfo{
		Name: "Respond",
		Desc: "Generate a direct response to the user. Use this tool when you have all the information needed to provide a final answer.",
		ParamsOneOf: schema.NewParamsOneOfByParams(
			map[string]*schema.ParameterInfo{
				"response": {
					Type:     schema.String,
					Desc:     "The complete response to provide to the user",
					Required: true,
				},
			},
		),
	}

	ExecutorUserPrompt = prompt.FromMessages(schema.FString, schema.UserMessage(
		`
## Given the following plan:
{plan}
## Your task is to execute the first step, which is: 
{step}`))

	ReplannerUserPrompt = prompt.FromMessages(schema.FString, schema.UserMessage(
		`You are going to review the progress toward an objective. Analyze the current state and determine the optimal next action.

## OBJECTIVE
{input}

## ORIGINAL PLAN
{plan}

## COMPLETED STEPS & RESULTS
{executed_steps}

## YOUR TASK
Based on the progress above, you MUST choose exactly ONE action:

### Option 1: COMPLETE (if objective is fully achieved)
Call '{respond_tool}' with:
- A comprehensive final answer
- Clear conclusion summarizing how the objective was met
- Key insights from the execution process

### Option 2: CONTINUE (if more work is needed)
Call '{plan_tool}' with a revised plan that:
- Contains ONLY remaining steps (exclude completed ones)
- Incorporates lessons learned from executed steps
- Addresses any gaps or issues discovered
- Maintains logical step sequence

## PLANNING REQUIREMENTS
Each step in your plan must be:
- **Specific and actionable**: Clear instructions that can be executed without ambiguity
- **Self-contained**: Include all necessary context, parameters, and requirements
- **Independently executable**: Can be performed by an agent without dependencies on other steps
- **Logically sequenced**: Arranged in optimal order for efficient execution
- **Objective-focused**: Directly contribute to achieving the main goal

## PLANNING GUIDELINES
- Eliminate redundant or unnecessary steps
- Adapt strategy based on new information
- Include relevant constraints, parameters, and success criteria for each step

## DECISION CRITERIA
- Has the original objective been completely satisfied?
- Are there any remaining requirements or sub-goals?
- Do the results suggest a need for strategy adjustment?
- What specific actions are still required?`))
)

const (
	PlanExecuteUserInputSessionKey = "UserInput"

	// PlannerInstruction is the system instruction for the planner.
	// It provides context and guidance to the planner on how to generate the Plan.
	PlannerInstruction = `You are an expert planning agent. Given an objective, create a comprehensive step-by-step plan to achieve the objective.

## YOUR TASK
Analyze the objective and generate a strategic plan that breaks down the goal into manageable, executable steps.

## PLANNING REQUIREMENTS
Each step in your plan must be:
- **Specific and actionable**: Clear instructions that can be executed without ambiguity
- **Self-contained**: Include all necessary context, parameters, and requirements
- **Independently executable**: Can be performed by an agent without dependencies on other steps
- **Logically sequenced**: Arranged in optimal order for efficient execution
- **Objective-focused**: Directly contribute to achieving the main goal

## PLANNING GUIDELINES
- Eliminate redundant or unnecessary steps
- Include relevant constraints, parameters, and success criteria for each step
- Ensure the final step produces a complete answer or deliverable
- Anticipate potential challenges and include mitigation strategies
- Structure steps to build upon each other logically
- Provide sufficient detail for successful execution

## QUALITY CRITERIA
- Plan completeness: Does it address all aspects of the objective?
- Step clarity: Can each step be understood and executed independently?
- Logical flow: Do steps follow a sensible progression?
- Efficiency: Is this the most direct path to the objective?
- Adaptability: Can the plan handle unexpected results or changes?`

	// PlanSessionKey is the session key for the plan.
	PlanSessionKey = "Plan"

	// ExecutedStepSessionKey is the session key for the execute result.
	ExecutedStepSessionKey = "ExecutedStep"

	// ExecutedStepsSessionKey is the session key for the execute results.
	ExecutedStepsSessionKey = "ExecutedSteps"
)

// PlannerConfig provides configuration options for creating a planner agent.
// There are two ways to configure the planner to generate structured Plan output:
//  1. Use ChatModelWithFormattedOutput: A model already configured to output in the Plan format
//  2. Use ToolCallingChatModel + ToolInfo: A model that will be configured to use tool calling
//     to generate the Plan structure
type PlannerConfig struct {
	// ChatModelWithFormattedOutput is a model pre-configured to output in the Plan format.
	// This can be created by configuring a model to output structured data directly.
	// Can refer to https://github.com/cloudwego/eino-ext/blob/main/components/model/openai/examples/structured/structured.go.
	ChatModelWithFormattedOutput model.BaseChatModel

	// ToolCallingChatModel is a model that supports tool calling capabilities.
	// When provided along with ToolInfo, the model will be configured to use tool calling
	// to generate the Plan structure.
	ToolCallingChatModel model.ToolCallingChatModel
	// ToolInfo defines the schema for the Plan structure when using tool calling.
	// If not provided, PlanToolInfo will be used as the default.
	ToolInfo *schema.ToolInfo

	GenInputFn GenPlannerInputFn

	PlanParser PlanParser
}

type PlannerInput struct {
	Input []adk.Message
}

type GenPlannerInputFn func(ctx context.Context, in *PlannerInput) ([]adk.Message, error)

func defaultPlanParserFn(ctx context.Context, arguments string) (Plan, error) {
	p := &executionPlan{}
	err := sonic.UnmarshalString(arguments, p)
	if err != nil {
		return nil, err
	}
	return p, nil
}

func defaultGenPlannerInputFn(ctx context.Context, in *PlannerInput) ([]adk.Message, error) {
	msgs := make([]adk.Message, 0, 1+len(in.Input))
	msgs = append(msgs, schema.SystemMessage(PlannerInstruction))
	msgs = append(msgs, in.Input...)
	return msgs, nil
}

type planner struct {
	toolCall   bool
	chatModel  model.BaseChatModel
	genInputFn GenPlannerInputFn
	planParser PlanParser
}

func (p *planner) Name(_ context.Context) string {
	return "Planner"
}

func (p *planner) Description(_ context.Context) string {
	return "a planner agent"
}

func argToContent(msg adk.Message) (adk.Message, error) {
	if len(msg.ToolCalls) == 0 {
		return nil, schema.ErrNoValue
	}

	return schema.AssistantMessage(msg.ToolCalls[0].Function.Arguments, nil), nil
}

func (p *planner) Run(ctx context.Context, input *adk.AgentInput,
	_ ...adk.AgentRunOption) *adk.AsyncIterator[*adk.AgentEvent] {

	iterator, generator := adk.NewAsyncIteratorPair[*adk.AgentEvent]()

	adk.SetSessionValue(ctx, PlanExecuteUserInputSessionKey, input.Messages)

	go func() {
		defer func() {
			panicErr := recover()
			if panicErr != nil {
				e := safe.NewPanicErr(panicErr, debug.Stack())
				generator.Send(&adk.AgentEvent{Err: e})
			}

			generator.Close()
		}()

		msgs, err := p.genInputFn(ctx, &PlannerInput{
			Input: input.Messages,
		})
		if err != nil {
			generator.Send(&adk.AgentEvent{Err: err})
			return
		}
		var modelCallOptions []model.Option
		if p.toolCall {
			modelCallOptions = append(modelCallOptions, model.WithToolChoice(schema.ToolChoiceForced))
		}

		var msg adk.Message
		if input.EnableStreaming {
			s, err_ := p.chatModel.Stream(ctx, msgs, modelCallOptions...)
			if err_ != nil {
				generator.Send(&adk.AgentEvent{Err: err_})
				return
			}

			ss := s.Copy(2)
			var sOutput *schema.StreamReader[*schema.Message]
			if p.toolCall {
				sOutput = schema.StreamReaderWithConvert(ss[0], argToContent)
			} else {
				sOutput = ss[0]
			}

			event := adk.EventFromMessage(nil, sOutput, schema.Assistant, "")
			generator.Send(event)

			msg, err_ = schema.ConcatMessageStream(ss[1])
			if err_ != nil {
				generator.Send(&adk.AgentEvent{Err: err_})
				return
			}

			if p.toolCall && len(msg.ToolCalls) == 0 {
				generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
				return
			}
		} else {
			var err_ error
			msg, err_ = p.chatModel.Generate(ctx, msgs, modelCallOptions...)
			if err_ != nil {
				generator.Send(&adk.AgentEvent{Err: err_})
				return
			}

			var output adk.Message
			if p.toolCall {
				if len(msg.ToolCalls) == 0 {
					generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
					return
				}
				output = schema.AssistantMessage(msg.ToolCalls[0].Function.Arguments, nil)
			} else {
				output = msg
			}

			event := adk.EventFromMessage(output, nil, schema.Assistant, "")
			generator.Send(event)
		}

		var planJSON string
		if p.toolCall {
			planJSON = msg.ToolCalls[0].Function.Arguments
		} else {
			planJSON = msg.Content
		}
		plan, err := p.planParser(ctx, planJSON)
		if err != nil {
			err = fmt.Errorf("unmarshal plan error: %w", err)
			generator.Send(&adk.AgentEvent{Err: err})
			return
		}

		adk.SetSessionValue(ctx, PlanSessionKey, plan)
	}()

	return iterator
}

// NewPlanner creates a new planner agent based on the provided configuration.
// The planner agent uses either ChatModelWithFormattedOutput or ToolCallingChatModel+ToolInfo
// to generate structured Plan output.
//
// If ChatModelWithFormattedOutput is provided, it will be used directly.
// If ToolCallingChatModel is provided, it will be configured with ToolInfo (or PlanToolInfo by default)
// to generate structured Plan output.
func NewPlanner(_ context.Context, cfg *PlannerConfig) (adk.Agent, error) {
	var chatModel model.BaseChatModel
	var toolCall bool
	if cfg.ChatModelWithFormattedOutput != nil {
		chatModel = cfg.ChatModelWithFormattedOutput
	} else {
		toolCall = true
		toolInfo := cfg.ToolInfo
		if toolInfo == nil {
			toolInfo = &PlanToolInfo
		}

		var err error
		chatModel, err = cfg.ToolCallingChatModel.WithTools([]*schema.ToolInfo{toolInfo})
		if err != nil {
			return nil, err
		}
	}

	inputFn := cfg.GenInputFn
	if inputFn == nil {
		inputFn = defaultGenPlannerInputFn
	}

	planParser := cfg.PlanParser
	if planParser == nil {
		planParser = defaultPlanParserFn
	}

	return &planner{
		toolCall:   toolCall,
		chatModel:  chatModel,
		genInputFn: inputFn,
		planParser: planParser,
	}, nil
}

type PlanExecuteInput struct {
	Input         []adk.Message
	Plan          Plan
	ExecutedSteps []ExecutedStep
}
type GenPlanExecuteInputFn func(ctx context.Context, in *PlanExecuteInput) ([]adk.Message, error)

type ExecutorConfig struct {
	Model       model.ToolCallingChatModel
	ToolsConfig adk.ToolsConfig
	MaxStep     int

	GenInputFn GenPlanExecuteInputFn
}

type ExecutedStep struct {
	Step   string
	Result string
}

// NewExecutor creates a new executor agent.
func NewExecutor(ctx context.Context, cfg *ExecutorConfig) (adk.Agent, error) {

	genInputFn := cfg.GenInputFn
	if genInputFn == nil {
		genInputFn = defaultGenExecutorInputFn
	}
	genInput := func(ctx context.Context, instruction string, _ *adk.AgentInput) ([]adk.Message, error) {

		plan, ok := adk.GetSessionValue(ctx, PlanSessionKey)
		if !ok {
			panic("impossible: plan not found")
		}
		plan_ := plan.(Plan)

		userInput, ok := adk.GetSessionValue(ctx, PlanExecuteUserInputSessionKey)
		if !ok {
			panic("impossible: user input not found")
		}
		userInput_ := userInput.([]adk.Message)

		var executedSteps_ []ExecutedStep
		executedStep, ok := adk.GetSessionValue(ctx, ExecutedStepsSessionKey)
		if ok {
			executedSteps_ = executedStep.([]ExecutedStep)
		}

		in := &PlanExecuteInput{
			Input:         userInput_,
			Plan:          plan_,
			ExecutedSteps: executedSteps_,
		}

		msgs, err := genInputFn(ctx, in)
		if err != nil {
			return nil, err
		}

		return msgs, nil
	}

	agent, err := adk.NewChatModelAgent(ctx, &adk.ChatModelAgentConfig{
		Name:          "Executor",
		Description:   "an executor agent",
		Model:         cfg.Model,
		ToolsConfig:   cfg.ToolsConfig,
		GenModelInput: genInput,
		MaxStep:       cfg.MaxStep,
		OutputKey:     ExecutedStepSessionKey,
	})
	if err != nil {
		return nil, err
	}

	return agent, nil
}

func defaultGenExecutorInputFn(ctx context.Context, in *PlanExecuteInput) ([]adk.Message, error) {

	userMsgs, err := ExecutorUserPrompt.Format(ctx, map[string]any{
		"input": formatInput(in.Input),
		"plan":  in.Plan.Description(ctx),
		"step":  in.Plan.FirstStep(ctx),
	})
	if err != nil {
		return nil, err
	}

	return userMsgs, nil
}

type replanner struct {
	chatModel   model.ToolCallingChatModel
	planTool    *schema.ToolInfo
	respondTool *schema.ToolInfo

	genInputFn GenPlanExecuteInputFn
	planParser PlanParser
}

type ReplannerConfig struct {

	// ChatModel is the model that supports tool calling capabilities.
	// It will be configured with PlanTool and RespondTool to generate updated plans or responses.
	ChatModel model.ToolCallingChatModel

	// PlanTool defines the schema for the Plan tool that can be used with ToolCallingChatModel.
	// If not provided, the default PlanToolInfo will be used.
	PlanTool *schema.ToolInfo

	// RespondTool defines the schema for the response tool that can be used with ToolCallingChatModel.
	// If not provided, the default RespondToolInfo will be used.
	RespondTool *schema.ToolInfo

	GenInputFn GenPlanExecuteInputFn

	PlanParser PlanParser
}

func formatInput(input []adk.Message) string {
	var sb strings.Builder
	for _, msg := range input {
		sb.WriteString(msg.Content)
		sb.WriteString("\n")
	}

	return sb.String()
}

func formatExecutedSteps(results []ExecutedStep) string {
	var sb strings.Builder
	for _, result := range results {
		sb.WriteString(fmt.Sprintf("Step: %s\nResult: %s\n\n", result.Step, result.Result))
	}

	return sb.String()
}

func (r *replanner) Name(_ context.Context) string {
	return "Replanner"
}

func (r *replanner) Description(_ context.Context) string {
	return "a replanner agent"
}

func (r *replanner) genInput(ctx context.Context) ([]adk.Message, error) {

	executedStep, ok := adk.GetSessionValue(ctx, ExecutedStepSessionKey)
	if !ok {
		panic("impossible: execute result not found")
	}
	executedStep_ := executedStep.(string)

	plan, ok := adk.GetSessionValue(ctx, PlanSessionKey)
	if !ok {
		panic("impossible: plan not found")
	}
	plan_ := plan.(Plan)
	step := plan_.FirstStep(ctx)

	var executedSteps_ []ExecutedStep
	executedSteps, ok := adk.GetSessionValue(ctx, ExecutedStepsSessionKey)
	if ok {
		executedSteps_ = executedSteps.([]ExecutedStep)
	}

	executedSteps_ = append(executedSteps_, ExecutedStep{
		Step:   step,
		Result: executedStep_,
	})
	adk.SetSessionValue(ctx, ExecutedStepsSessionKey, executedSteps_)

	userInput, ok := adk.GetSessionValue(ctx, PlanExecuteUserInputSessionKey)
	if !ok {
		panic("impossible: user input not found")
	}
	userInput_ := userInput.([]adk.Message)

	in := &PlanExecuteInput{
		Input:         userInput_,
		Plan:          plan_,
		ExecutedSteps: executedSteps_,
	}
	genInputFn := r.genInputFn
	if genInputFn == nil {
		genInputFn = buildDefaultReplannerInputFn(in, r.planTool.Name, r.respondTool.Name)
	}
	msgs, err := genInputFn(ctx, in)
	if err != nil {
		return nil, err
	}

	return msgs, nil
}

func (r *replanner) Run(ctx context.Context, input *adk.AgentInput, _ ...adk.AgentRunOption) *adk.AsyncIterator[*adk.AgentEvent] {
	iterator, generator := adk.NewAsyncIteratorPair[*adk.AgentEvent]()
	msgs, err := r.genInput(ctx)
	if err != nil {
		generator.Send(&adk.AgentEvent{Err: err})
		generator.Close()
		return iterator
	}

	go func() {
		defer func() {
			panicErr := recover()
			if panicErr != nil {
				e := safe.NewPanicErr(panicErr, debug.Stack())
				generator.Send(&adk.AgentEvent{Err: e})
			}

			generator.Close()
		}()

		callOpt := model.WithToolChoice(schema.ToolChoiceForced)

		var planMsg adk.Message
		if input.EnableStreaming {
			var s adk.MessageStream
			s, err = r.chatModel.Stream(ctx, msgs, callOpt)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			ss := s.Copy(2)
			sOutput := schema.StreamReaderWithConvert(ss[0], argToContent)
			event := adk.EventFromMessage(nil, sOutput, schema.Assistant, "")
			generator.Send(event)

			var chunks []adk.Message
			s = ss[1]
			var isResponse bool
			for {
				chunk, err_ := s.Recv()
				if err_ != nil {
					if err_ == io.EOF {
						break
					}

					generator.Send(&adk.AgentEvent{Err: err_})
					return
				}

				if len(chunk.ToolCalls) > 0 && chunk.ToolCalls[0].Function.Name == r.respondTool.Name {
					isResponse = true
					break
				}

				chunks = append(chunks, chunk)
			}
			s.Close()

			if isResponse {
				action := adk.NewExitAction()
				generator.Send(&adk.AgentEvent{Action: action})
				return
			}

			planMsg, err = schema.ConcatMessages(chunks)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			if len(planMsg.ToolCalls) == 0 {
				generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
				return
			}
		} else {
			var msg adk.Message
			msg, err = r.chatModel.Generate(ctx, msgs, callOpt)
			if err != nil {
				generator.Send(&adk.AgentEvent{Err: err})
				return
			}

			if len(msg.ToolCalls) > 0 {
				output := schema.AssistantMessage(msg.ToolCalls[0].Function.Arguments, nil)
				event := adk.EventFromMessage(output, nil, schema.Assistant, "")
				generator.Send(event)

				if len(msg.ToolCalls) > 0 && msg.ToolCalls[0].Function.Name == r.respondTool.Name {
					action := adk.NewExitAction()
					generator.Send(&adk.AgentEvent{Action: action})
					return
				}

				planMsg = msg
			} else {
				generator.Send(&adk.AgentEvent{Err: errors.New("no tool call")})
				return
			}
		}

		// handle plan tool call
		if planMsg.ToolCalls[0].Function.Name != r.planTool.Name {
			errMsg := fmt.Sprintf("unexpected tool call: %s", planMsg.ToolCalls[0].Function.Name)
			generator.Send(&adk.AgentEvent{Err: errors.New(errMsg)})
			return
		}

		plan_, err_ := r.planParser(ctx, planMsg.ToolCalls[0].Function.Arguments)
		if err_ != nil {
			err_ = fmt.Errorf("unmarshal plan error: %w", err_)
			generator.Send(&adk.AgentEvent{Err: err_})
			return
		}

		adk.SetSessionValue(ctx, PlanSessionKey, plan_)
	}()

	return iterator
}

func buildDefaultReplannerInputFn(in *PlanExecuteInput, planToolName, respondToolName string) GenPlanExecuteInputFn {
	return func(ctx context.Context, in *PlanExecuteInput) ([]adk.Message, error) {
		msgs, err := ReplannerUserPrompt.Format(ctx, map[string]any{
			"plan":           in.Plan.Description(ctx),
			"input":          formatInput(in.Input),
			"executed_steps": formatExecutedSteps(in.ExecutedSteps),
			"plan_tool":      planToolName,
			"respond_tool":   respondToolName,
		})
		if err != nil {
			return nil, err
		}

		return msgs, nil
	}
}

func NewReplanner(_ context.Context, cfg *ReplannerConfig) (adk.Agent, error) {
	planTool := cfg.PlanTool
	if planTool == nil {
		planTool = &PlanToolInfo
	}

	respondTool := cfg.RespondTool
	if respondTool == nil {
		respondTool = &RespondToolInfo
	}

	chatModel, err := cfg.ChatModel.WithTools([]*schema.ToolInfo{planTool, respondTool})
	if err != nil {
		return nil, err
	}

	planParser := cfg.PlanParser
	if planParser == nil {
		planParser = defaultPlanParserFn
	}

	return &replanner{
		chatModel:   chatModel,
		planTool:    planTool,
		respondTool: respondTool,
		genInputFn:  cfg.GenInputFn,
		planParser:  planParser,
	}, nil
}

type PlanExecuteConfig struct {
	Planner    adk.Agent
	Executor   adk.Agent
	Replanner  adk.Agent
	MaxReplans int
}

func NewPlanExecuteAgent(ctx context.Context, cfg *PlanExecuteConfig) (adk.Agent, error) {
	maxReplans := cfg.MaxReplans
	if maxReplans <= 0 {
		maxReplans = 10
	}
	loop, err := adk.NewLoopAgent(ctx, &adk.LoopAgentConfig{
		Name:          "execute_replan",
		SubAgents:     []adk.Agent{cfg.Executor, cfg.Replanner},
		MaxIterations: maxReplans,
	})
	if err != nil {
		return nil, err
	}

	return adk.NewSequentialAgent(ctx, &adk.SequentialAgentConfig{
		Name:      "plan_execute_replan",
		SubAgents: []adk.Agent{cfg.Planner, loop},
	})
}
